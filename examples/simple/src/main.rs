//! # Simple Gotcha Application
//!
//! This example demonstrates the new simplified Gotcha API that allows
//! you to create web applications without defining structs or implementing traits.
//!
//! Features demonstrated:
//! - Simple route definitions with closures
//! - Path parameters
//! - JSON responses
//! - Automatic OpenAPI documentation (visit /redoc)
//! - CORS support
//!
//! Run with: cargo run
//! Then visit: http://localhost:3000

use gotcha::prelude::*;

// Simple data structure for our API
#[derive(Serialize, Deserialize, Debug)]
struct User {
    id: u32,
    name: String,
    email: String,
}

#[derive(Serialize, Deserialize)]
struct CreateUserRequest {
    name: String,
    email: String,
}

#[derive(Serialize)]
struct HealthResponse {
    status: String,
    timestamp: String,
    version: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter("info,simple=debug")
        .init();

    println!("ðŸš€ Starting Simple Gotcha Server");
    println!("ðŸ“– API Documentation: http://localhost:3000/redoc");
    println!("ðŸ“Š OpenAPI Spec: http://localhost:3000/openapi.json");
    println!("ðŸ”§ Health Check: http://localhost:3000/health");
    
    // Create the application using the new builder API
    Gotcha::new()
        // Enable CORS for all origins (not recommended for production)
        .with_cors()
        
        // Enable OpenAPI documentation
        .with_openapi()
        
        // Simple text response
        .get("/", || async {
            "ðŸŽ‰ Welcome to Gotcha! Visit /redoc for API documentation."
        })
        
        // Health check endpoint with JSON response
        .get("/health", || async {
            Json(serde_json::json!({
                "status": "ok",
                "timestamp": "2024-01-01T00:00:00Z", // chrono::Utc::now().to_rfc3339(),
                "version": env!("CARGO_PKG_VERSION")
            }))
        })
        
        // Path parameter example
        .get("/hello/:name", |Path(name): Path<String>| async move {
            format!("ðŸ‘‹ Hello, {}! Welcome to Gotcha!", name)
        })
        
        // JSON response with path parameter
        .get("/users/:id", |Path(id): Path<u32>| async move {
            // In a real application, you would fetch this from a database
            let user = User {
                id,
                name: format!("User {}", id),
                email: format!("user{}@example.com", id),
            };
            Json(user)
        })
        
        // POST endpoint with JSON body
        .post("/users", |Json(req): Json<CreateUserRequest>| async move {
            // In a real application, you would save this to a database
            let user = User {
                id: 42, // Would be generated by the database
                name: req.name,
                email: req.email,
            };
            
            tracing::info!("Created user: {:?}", user);
            
            // Return 201 Created with the user data
            (StatusCode::CREATED, Json(user))
        })
        
        // Multiple HTTP methods for the same path
        .route("/echo", 
            post(|body: String| async move {
                format!("Echo: {}", body)
            })
            .put(|body: String| async move {
                format!("Put Echo: {}", body)
            })
        )
        
        // Nested routes using a closure
        .routes(|router| {
            router
                .get("/api/v1/ping", || async { "pong" })
                .get("/api/v1/time", || async {
                    "2024-01-01T00:00:00Z"
                })
        })
        
        // Error handling example
        .get("/error", || async {
            // This will return a 500 Internal Server Error
            Err::<String, _>("Something went wrong!")
        })
        
        // Custom status code
        .get("/teapot", || async {
            (StatusCode::IM_A_TEAPOT, "I'm a teapot! â˜•")
        })
        
        // HTML response
        .get("/html", || async {
            Html(r#"
                <h1>ðŸ¦€ Gotcha Framework</h1>
                <p>This is an HTML response from a Gotcha server!</p>
                <ul>
                    <li><a href="/">Home</a></li>
                    <li><a href="/health">Health Check</a></li>
                    <li><a href="/redoc">API Documentation</a></li>
                </ul>
            "#)
        })
        
        // Start the server
        .listen("127.0.0.1:3000")
        .await?;

    Ok(())
}

// Example of how you can still define separate handler functions
// if you prefer that over closures
async fn separate_handler() -> impl Responder {
    "This is a separate handler function"
}

// You can also have handlers that use the full context
// but this is typically not needed with the simple API
async fn _complex_handler(
    Path(id): Path<u32>,
    Json(data): Json<serde_json::Value>,
) -> Result<Json<serde_json::Value>, StatusCode> {
    if id > 100 {
        return Err(StatusCode::NOT_FOUND);
    }
    
    Ok(Json(serde_json::json!({
        "id": id,
        "received": data,
        "processed_at": "2024-01-01T00:00:00Z"
    })))
}